[comment encoding = UTF-8 /]
[module generateFlinkSinks('http://www.eclipse.org/emf/2002/Ecore', 'http://www.eclipse.org/uml2/5.0.0/UML')]

[import streamgen::main::queryUtils/]
 
[template public generateFlinkCassandraSink(aClass : Class)]
	CassandraSink.addSink([getInputNames(aClass)-> first()/])
    	.setHost("[getStereotypeProperty(aClass, 'CassandraSink', 'cassandraHost')/]")
    	.setMapperOptions(() -> new Mapper.Option['['/]]{Mapper.Option.saveNullFields(true)})
    	.build();
[/template]

[template public generateFlinkKafkaSink(aClass : Class)]
	FlinkKafkaProducer010<String> [aClass.name.toString().concat('_producer')/] = new FlinkKafkaProducer010<String>(
	        "[getStereotypeProperty(aClass, 'KafkaSink', 'kafkaBrokerIp')/]:[getStereotypeProperty(aClass, 'KafkaSink', 'kafkaBrokerPort')/]",            
	        "[aClass.name.toString()/]",                 
	        new SimpleStringSchema()); 

	 [getInputNames()->first()/].map(([getInputsConveyed(aClass)->first()/] x) -> x.toString()).addSink([aClass.name.toString().concat('_producer')/]);
[/template]

[template public generateFlinkTextFileSink(aClass : Class)
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	[if (aClass.getTargetDirectedRelationships()->asSequence() -> collect(r | r.eGet('conveyed'))->first().oclAsType(Class).attribute -> exists(a | a.name= 'dataSubject'))]
	ProtectedStream<SubjectSpecific> [input.eGet('name')/]_p = new ProtectedStream<SubjectSpecific>(monitoringActive, timestampServerIp,
			timestampServerPort, topologyParallelism, simulateRealisticScenario, allowedLateness);
	[input.eGet('name')/]_p.setStreamToProtect((DataStream<SubjectSpecific>) app.getStreamByID("[input.eGet('name')/]").getConcreteStream());

	//////////////
	[input.eGet('name')/]_p.addGeneralizationFunction("content", new Integer(1), new GeneralizationFunction());
	//////////////

	for (VCP vcp : app.getVCPs(app.getStreamByID("[input.eGet('name')/]").getId())) {
		[input.eGet('name')/]_p.addVCP(app.getStreamByID("[input.eGet('name')/]"), (VCP) vcp, app);
	}

	for (DSEP dsep : app.getDSEPs(app.getStreamByID("[input.eGet('name')/]").getId())) {
		[input.eGet('name')/]_p.addDSEP(app.getStreamByID("[input.eGet('name')/]"), (DSEP) dsep, app);
	}
	[input.eGet('name')/]_p.finalize(env, contextStream)
		[if input.hasStereotype('KeyedStream') ]
		.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
		[/if]
		.writeAsText("[getStereotypeProperty(aClass, 'TextFileSink', 'filepath')/]")
		[comment: the parallelism should be set only if it differes from the topology level parallelism. This applies to every operation./]
		.setParallelism([getParallelism(aClass, 'TextFileSink')/]);
	[else]
	[input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
		.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
		[/if]
		.writeAsText("[getStereotypeProperty(aClass, 'TextFileSink', 'filepath')/]")
		[comment: the parallelism should be set only if it differes from the topology level parallelism. This applies to every operation./]
		.setParallelism([getParallelism(aClass, 'TextFileSink')/]);
	[/if]

[/template]

[template public generateFlinkCsvFileSink(aClass : Class)
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	[input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
		.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
		[/if]
		.writeAsText("[getStereotypeProperty(aClass, 'CsvFileSink', 'filepath')/]")
		[comment: the parallelism should be set only if it differes from the topology level parallelism. This applies to every operation./]
		.setParallelism([getParallelism(aClass, 'CsvFileSink')/]);
[/template]