[comment encoding = UTF-8 /]
[module generateFlinkTransformations('http://www.eclipse.org/emf/2002/Ecore', 'http://www.eclipse.org/uml2/5.0.0/UML')]

[import streamgen::main::queryUtils/]

[template public generateFlinkMapTransformation(aClass : Class) 
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	DataStream<[getOutputsConveyed(aClass) ->first()/]> [getOutputNames(aClass)->first()/] = [input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
      	[/if]
		.map(new [aClass.name/]())
		[if getParallelism(aClass, 'MapTransformation') > 1 ]
		.setParallelism([getParallelism(aClass, 'MapTransformation')/]);
		[else]
		;
		[/if]
[/template]

[template public generateFlinkFlatmapTransformation(aClass : Class)
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	DataStream<[getOutputsConveyed(aClass) ->first()/]> [getOutputNames(aClass)->first()/] = [input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
      	[/if]
		.flatMap(new [aClass.name/]())
		[if getParallelism(aClass, 'FlatmapTransformation').toString().toInteger() > 1 ]
		.setParallelism([getParallelism(aClass, 'FlatmapTransformation')/]);
		[else]
		;
		[/if]
[/template]

[template public generateFlinkCoFlatmapTransformation(aClass : Class)
	{first : DirectedRelationship = getInputs(aClass)->at(1);
	 second : DirectedRelationship = getInputs(aClass)->at(2);}]
	DataStream<[getOutputsConveyed(aClass) ->first()/]> [getOutputNames(aClass)->first()/] = [first.eGet('name')/]
		[if first.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(first, 'KeyedStream', 'key').eGet('name')/]")
		[elseif first.hasStereotype('BroadcastedStream')]
		.broadcast()
      	[/if]
		.connect(
		[second.eGet('name')/]
		[if second.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(second, 'KeyedStream', 'key').eGet('name')/]")
		[elseif second.hasStereotype('BroadcastedStream')]
		.broadcast()
      	[/if]
		)
		.flatMap(new [aClass.name/]())
		[if getParallelism(aClass, 'NFlatmapTransformation').toString().toInteger() > 1 ]
		.setParallelism([getParallelism(aClass, 'FlatmapTransformation')/]);
		[else]
		;
		[/if]
[/template]

[template public generateFlinkReduceTransformation(aClass : Class)]
[/template]

[template public generateFlinkFilterTransformation(aClass : Class)
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	DataStream<[getOutputsConveyed(aClass) ->first()/]> [getOutputNames(aClass)->first()/] = [input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
      	[/if]
		.filter(([getInputsConveyed(aClass) ->first()/] tuple) -> [getStereotypeProperty(aClass, 'FilterTransformation', 'filteringCondition')/])
		[if getParallelism(aClass, 'FilterTransformation').toString().toInteger() > 1 ]
		.setParallelism([getParallelism(aClass, 'FilterTransformation')/]);
		[else]
		;
		[/if]
[/template]

[template public generateFlinkJoinTransformation(aClass : Class)]
[/template]

[template public generateFlinkWindowTransformation(aClass : Class)
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	DataStream<[getOutputsConveyed(aClass) ->first()/]> [getOutputNames(aClass)->first()/] = [input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
      	[/if] 
		[if input.hasStereotype('WindowedStream') ] [comment -- this should be actually guaranteed by the OCL constraint. /]
            [if input.getStereotypeProperty('WindowedStream', 'window').eGet('isSessionInEventTime').toString().toBoolean() = true]
		.timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](EventTimeSessionWindows.withGap(Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/])))
			[elseif input.getStereotypeProperty('WindowedStream', 'window').eGet('isSessionInProcessingTime').toString().toBoolean() = true]
        .timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](ProcesingTimeSessionWindows.withGap(Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/])))
            [else]
              [if input.getStereotypeProperty('WindowedStream', 'window').eGet('isSliding').toString().toBoolean() = false]
        .timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/]))
              [else]
        .timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/]),Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('slideSize').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('slideSize').eGet('size')/]))          
              [/if]
            [/if]
      	[/if] 
        .apply(new [aClass.name/]())
		[if getParallelism(aClass, 'WindowTransformation') > 1 ]
		.setParallelism([getParallelism(aClass, 'WindowTransformation')/]);
		[else]
		;
		[/if]
[/template]

[template public generateFlinkSumTransformation(aClass : Class)
	{input : DirectedRelationship = getInputs(aClass)->first();}]
	DataStream<[getOutputsConveyed(aClass) ->first()/]> [getOutputNames(aClass)->first()/] = [input.eGet('name')/]
		[if input.hasStereotype('KeyedStream') ]
      	.keyBy("[getStereotypeProperty(input, 'KeyedStream', 'key').eGet('name')/]")
      	[/if] 
		[if input.hasStereotype('WindowedStream') ] [comment -- this should be actually guaranteed by the OCL constraint. /]
            [if input.getStereotypeProperty('WindowedStream', 'window').eGet('isSessionInEventTime').toString().toBoolean() = true]
		.timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](EventTimeSessionWindows.withGap(Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/])))
			[elseif input.getStereotypeProperty('WindowedStream', 'window').eGet('isSessionInProcessingTime').toString().toBoolean() = true]
        .timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](ProcesingTimeSessionWindows.withGap(Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/])))
            [else]
              [if input.getStereotypeProperty('WindowedStream', 'window').eGet('isSliding').toString().toBoolean() = false]
        .timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/]))
              [else]
        .timeWindow[if input.hasStereotype('NonParallelStream')]All[/if](Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('size').eGet('size')/]),Time.[input.getStereotypeProperty('WindowedStream', 'window').eGet('slideSize').eGet('timeUnit').toString().toLower()/]([input.getStereotypeProperty('WindowedStream', 'window').eGet('slideSize').eGet('size')/]))          
              [/if]
            [/if]
      	[/if] 
		.sum("[getStereotypeProperty(aClass, 'SumTransformation', 'field').eGet('name')/]")
		[if getParallelism(aClass, 'SumTransformation') > 1 ]
		.setParallelism([getParallelism(aClass, 'SumTransformation')/]);
		[else]
		;
		[/if]  
[/template]

[template public generateFlinkTensorflowTransformation(aClass : Class)
{input : DirectedRelationship = getInputs(aClass)->first();}]
	TensorflowTools t = new TensorflowTools();
		byte[ '[' /][ ']' /] graphDef = t.readAllBytesOrExit(Paths.get([getStereotypeProperty(aClass, 'FlinkTensorflowTransformation', 'pathToFolder')/], "tensorflow_inception_graph.pb"));
	    List<String> labels = t.readAllLinesOrExit(Paths.get(args[ '[' /]0[ ']' /], "imagenet_comp_graph_label_strings.txt"));
		DataStream<Tensor<Float>> tensor = [input.eGet('name')/].map(new MapFunction<byte[ '[' /][ ']' /],Tensor<Float>>(){

			@Override
			public Tensor<Float> map(byte[ '[' /][ ']' /] imageBytes) throws Exception {
				return t.constructAndExecuteGraphToNormalizeImage(imageBytes);
			}
		}).[if getParallelism(aClass, 'FlinkTensorflowTransformation').toString().toInteger() > 1 ]
			.setParallelism([getParallelism(aClass, 'FlinkTensorflowTransformation')/]);
			[else]
			;
			[/if]
		
		DataStream<float[ '[' /][ ']' /]> probabilities = tensor.map(new MapFunction<Tensor<Float>,float[ '[' /][ ']' /]>(){

			@Override
			public float[ '[' /][ ']' /] map(Tensor<Float> tensor) throws Exception {
				return t.executeInceptionGraph(graphDef, tensor);
			}
		})[if getParallelism(aClass, 'FlinkTensorflowTransformation').toString().toInteger() > 1 ]
			.setParallelism([getParallelism(aClass, 'FlinkTensorflowTransformation')/]);
			[else]
			;
			[/if]
		
		DataStream<String> [getOutputNames(aClass)->first()/] = probabilities.map(new MapFunction<float[ '[' /][ ']' /],String>(){

			@Override
			public String map(float[ '[' /][ ']' /] probabilities) throws Exception {
				int[ '[' /][ ']' /] bestIndexes = t.bestThreeProbabilities(probabilities);
				return new String(String.format("Most likely: %s\n", labels.get(bestIndexes[ '[' /]0[ ']' /])));
			}
		});
[/template]